"""#1 Реализовать класс Matrix (матрица). Обеспечить перегрузку конструктора класса (метод init()), который должен
принимать данные (список списков) для формирования матрицы. Подсказка: матрица — система некоторых математических
величин, расположенных в виде прямоугольной схемы. Примеры матриц вы найдете в методичке. Следующий шаг — реализовать
перегрузку метода str() для вывода матрицы в привычном виде. Далее реализовать перегрузку метода add() для реализации
операции сложения двух объектов класса Matrix (двух матриц). Результатом сложения должна быть новая матрица.
Подсказка: сложение элементов матриц выполнять поэлементно — первый элемент первой строки первой матрицы складываем с
первым элементом первой строки второй матрицы и т.д. """

#
# class Matrix():
#     def __init__(self,my_list):
#         self.my_list = my_list
#
#     def __str__(self):
#         return '\n'.join(map(str, self.my_list))
#
#     def __add__(self, other):
#         for i in range(len(self.my_list)):
#             for i_2 in range(len(other.my_list[i])):
#                 self.my_list[i][i_2] = self.my_list[i][i_2] + other.my_list[i][i_2]
#
#         return Matrix.__str__(self)
#
#
# m = Matrix([[1, 2], [3, 4], [5, 6], [7, 8]])
# new_m = Matrix([[2, 1], [4, 3], [6, 5], [8, 7]])
# print(m.__add__(new_m))
# print(type(m.__add__(new_m)))

"""# 2Реализовать проект расчета суммарного расхода ткани на производство одежды. Основная сущность (класс) этого
проекта — одежда, которая может иметь определенное название. К типам одежды в этом проекте относятся пальто и костюм.
У этих типов одежды существуют параметры: размер (для пальто) и рост (для костюма). Это могут быть обычные числа: V и
H, соответственно. Для определения расхода ткани по каждому типу одежды использовать формулы: для пальто (V/6.5 +
0.5), для костюма (2 * H + 0.3). Проверить работу этих методов на реальных данных. Реализовать общий подсчет расхода
ткани. Проверить на практике полученные на этом уроке знания: реализовать абстрактные классы для основных классов
проекта, проверить на практике работу декоратора @property. """

#
# from abc import ABC, abstractmethod
#
# class Clothes(ABC):
#
#     def __init__(self, param):
#         self.param = param
#
#     @property
#     def consumption(self):
#         return f'Сумма затраченной ткани равна: {self.param / 6.5 + 0.5 + 2 * self.param + 0.3 :.2f}'
#
#
# class Coat(Clothes):
#
#     @property
#     def consumption_coat(self):
#         return f"Для пошива пальто нужно: {self.param / 6.5 + 0.5 :.2f} ткани"
#
# class Costume(Clothes):
#
#     @property
#     def consumption_costume(self):
#         return f'Для пошива костюма нужно: {2 * self.param + 0.3 :.2f} ткани'
#
#
# coat = Coat(40)
# costume = Costume(25)
# print(coat.consumption_coat)
# print(costume.consumption_costume)


"""Реализовать программу работы с органическими клетками, состоящими из ячеек. Необходимо создать класс Клетка. В его 
конструкторе инициализировать параметр, соответствующий количеству ячеек клетки (целое число). В классе должны быть 
реализованы методы перегрузки арифметических операторов: сложение (__add__()), вычитание (__sub__()), умножение (
__mul__()), деление (__truediv__()). Данные методы должны применяться только к клеткам и выполнять увеличение, 
уменьшение, умножение и обычное (не целочисленное) деление клеток, соответственно. В методе деления должно 
осуществляться округление значения до целого числа. 
- Сложение. Объединение двух клеток. При этом число ячеек общей 
клетки должно равняться сумме ячеек исходных двух клеток. 
- Вычитание. Участвуют две клетки. Операцию необходимо 
выполнять только если разность количества ячеек двух клеток больше нуля, иначе выводить соответствующее сообщение. 
- Умножение. Создается общая клетка из двух. Число ячеек общей клетки определяется как произведение количества ячеек 
этих двух клеток. 
- Деление. Создается общая клетка из двух. Число ячеек общей клетки определяется как целочисленное 
деление количества ячеек этих двух клеток. 
В классе необходимо реализовать метод make_order(), принимающий экземпляр класса и количество ячеек в ряду. 
Данный метод позволяет организовать ячейки по рядам. Метод должен возвращать строку 
вида *****\n*****\n*****..., где количество ячеек между \n равно переданному аргументу. Если ячеек на формирование 
ряда не хватает, то в последний ряд записываются все оставшиеся."""


class Cell:
    def __init__(self, amount):
        self.amount = amount

    def __add__(self, other):
        return f"В результате слияния клеток получатеся клетка в {self.amount + other.amount}"

    def __sub__(self, other):
        if self.amount - other.amount > 0:
            return f"В результате борьбы за существование получается клетка в {self.amount - other.amount}"
        elif self.amount - other.amount == 0:
            return f"В результате борьбы за существование все обнулились"
        else:
            return f"В результате борьбы за существование все погибли"

    def __mul__(self, other):
        return f"В результате размножения клеток получатеся клетка в {self.amount * other.amount}"

    def __truediv__(self, other):
        return f"В результате деления клеток получатеся клетка в {self.amount // other.amount}"

    def make_order(self, rows):
        a = "#"
        print(f"{a * int(self.amount / rows)}\n" * rows,"#" * int(self.amount % rows))



cell_a = Cell(25)
cell_b = Cell(5)
print(cell_a + cell_b)
print(cell_a - cell_b)
print(cell_a * cell_b)
print(cell_a / cell_b)
print(cell_a.make_order(3))
